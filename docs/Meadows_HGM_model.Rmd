---
title: "NDVI-HGM-WQ Model"
author: "Ryan Peek"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output:
 html_document:
   highlight: pygments
   theme: yeti
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load-libs, echo=FALSE}
suppressPackageStartupMessages({
  library(dplyr)
	library(ggplot2)
  library(viridis)
	library(ggthemes)
  library(lubridate)
	library(leaflet)
  library(readr)
  #library(quickmapr)
  library(rethinking)
  library(rgdal)
  library(DT)
  #library(ggrepel)
  })

snmmc.mdws<-read_rds("./data_output/UCD_mdw_df.rds") # UCD Dataset for 17,039 meadows

```

# Data Filtering and Merging

Take original data from previous and munge and merge with updated Dave Weixelman meadows that were selected.

```{r munge-orig-data, eval=F, echo=F}

wx.mdw<-read_rds("./data_output/wx_mdw_dat.rds") # weixelman data for 114 meadows

# rename and sort columns a bit
# Drop HGM source_type 8 (Dry), and combine classes 6 and 7, add elev col

wx.mdw <- wx.mdw %>% 
  select(PLOT, UCDavisObject_ID:PLOTNAME2, AREA_ACRE:Shape_Area) %>% 
  rename(Method=METHOD.y, UCDID=UCDavisObject_ID) %>% 
  mutate(hgm_class_comb = ifelse(source_type==8, NA, source_type), 
         hgm_class_comb = ifelse(source_type==7, 6, hgm_class_comb),
         elev_av_2100 = ifelse(ELEV_MEAN<2100, "<2100",">=2100"))

## make a quick meadows type table
mdw_types<-c("lacustrine fringe", "depressional",
             "discharge-slope-hillslope",
             "riparian-discharge-slope", "riparian",
             "subsurface-discharge-slope",
             "subsurface", "dry")
mdw_type_code<-c("lf", "dep", "ds", "rip-ds",
                 "rip", "sub-ds", "sub", "dry")
mdw_type_class<-seq(1,8,1)

# bind df
mdw_hgms<-data.frame("hgm_type"=mdw_types,"hgm_code"=mdw_type_code, "hgm_class"=mdw_type_class )

# now join this with original dataset
wx.mdw2<-inner_join(wx.mdw, mdw_hgms, by=c("source_type"="hgm_class"))
head(as.data.frame(wx.mdw2[,c(2,14,16,44:47)]))

# save for easy reload next time:
# write_rds(x = wx.mdw2, path ="~/Documents/github/meadow_hgm_waterchem/data_output/wx_mdw_dat2.rds")

```

First filter data to only selected data (`OK` and not `DRY` or `NOT OK`) based on Dave Weixelman's excel file from **June 05, 2016**. Several meadows were not accessible and were dropped, final list only includes data where there were UCDSNM_ID matched. Second, recombine and drop HGM classes (*drop dry category `8` and merge `6 & 7`*). Finally write back out as *.rds* file.

```{r load revised data, eval=F, echo=F}

wx.mdw<-read_rds("./data_output/wx_mdw_dat2.rds")

# this is the updated data version: 
wx.mdw.sub<-read_csv("./data/water_source_MDW_selection_2016_10_07.csv")
head(wx.mdw.sub)
wx.mdw.sub %>% ggplot + aes(x=hgm_classes, fill=elev_av_2100) + geom_bar()

# filter out the "NOT OK" and select cols of interest:
wx.mdw.sub <- wx.mdw.sub %>% 
  mutate(selected=1)
wx.mdw.sub %>% tally(selected) # should be 33 here!

# keep only selected and see how many matches occur:
dim(inner_join(wx.mdw, wx.mdw.sub, by="PLOT"))  # only 19 match up!
dim(inner_join(wx.mdw, wx.mdw.sub, by=c("UCDID"="UCDavisObject_ID")))  # 24 match up!
dim(merge(wx.mdw, wx.mdw.sub, by.x="UCDID", by.y="UCDavisObject_ID", all.y=T))

# this is the refiltered data...based on Dave's comments. Re-merge with dataset
wx.mdw.sub.UCID<-left_join(wx.mdw.sub, wx.mdw, by=c("UCDavisObject_ID"="UCDID")) %>% 
  distinct(UCDavisObject_ID,.keep_all = T) %>% 
  select(-ends_with(".y"), -c(STATE:Shape_Area)) %>% 
  rename_(.dots=setNames(names(.), gsub("\\.x", "", names(.))))

names(wx.mdw.sub.UCID)
summary(wx.mdw.sub.UCID)

# write to CSV and fill in blanks:
write_csv(wx.mdw.sub.UCID, path = "./data_output/wx_mdw_sub_UCID.csv")
# ok write this out to merge with GEE data later
# write_rds(x = wx.mdw.sub.UCID, path ="~/Documents/github/meadow_hgm_waterchem/data_output/wx_mdw_sub_UCDID.rds")
```

### Merge with Google Earth Engine Data

Need to merge with original GEE data after removing duplicated columns, then filter, rename a col, and save out.

```{r GEE clean and merge, eval=F, echo=F}
# HGM data ----
wx.mdw.sub<-read_csv(file = "./data_output/wx_mdw_sub_UCID.csv")
str(wx.mdw.sub)

# Make a list of duplicated column names (from SNMMC data) to filter from merge:
wx<-names(wx.mdw.sub)
gee<-names(snmmc.mdws)
allcols<-c(wx, gee)
col.dups <- allcols[duplicated(allcols)]

# now select columns that aren't duplicated before merging
library(magrittr) # to allow for special pipes %<>%
wx.mdw.sub %<>% select(-one_of(col.dups)) # writes back to same object
names(wx.mdw.sub)

# merge with GEE data
mdw.mod.dat<-inner_join(wx.mdw.sub, snmmc.mdws, by=c("UCDavisObject_ID"="ID"))
mdw.mod.dat %<>% select(-HGM_TYPE) %>%  dplyr::rename(., UCDID = UCDavisObject_ID)
names(mdw.mod.dat) # 47 variables, complete dataset

unique(mdw.mod.dat$UCDID) # should have 22!

## GET GEE DATA AND BIND NDVI w NDWI ------

folder='raw/'
get_csv <- list.files(folder, pattern = "*.csv")

mdws_gee <- data.frame()
for(i in 1:length(get_csv)) {
  csv<-read.csv(paste(folder,get_csv[i], sep=""), colClasses = "character")
  mdws_gee<-rbind(csv, mdws_gee)
  rm(csv)
  }

# Now Clean Up Rows
source(file='./scripts/functions/gee_data_cleanup.R')
# clean up df
mdws_gee_dat <- gee_tidy_df(mdws_gee)

# Add Water Year Cols
source("./scripts/functions/doy.R")
mdws_gee_dat$date<-ymd(mdws_gee_dat$date)
mdws_gee_dat$WY<-wtr_yr(mdws_gee_dat$date)
mdws_gee_dat$DOWY<-dowy(mdws_gee_dat$date)
mdws_gee_dat$DOY<-yday(mdws_gee_dat$date)
summary(mdws_gee_dat)

## Add WYT
wy <- read.csv("./data/wy_type.csv")

add_wy_type<-function(df, wy_df, region){
  vars <- c("WY", region)
  wy_region <- wy[vars]
  names(wy_region)[names(wy_region)==region] <- "WYTYPE"
  df<-merge(df, wy_region, by="WY")
  return(df)
}

mdws_gee_dat <- add_wy_type(mdws_gee_dat, wy, "SJ")

#write_rds(mdws_gee_dat, path="./data_output/hgm_mdws_gee_dat.rds")
#mdws_gee_dat<-read_rds(path="./data_output/hgm_mdws_gee_dat.rds")

# remove temporary data
rm(mdws_gee)

## Filter and Join Mdws ------
mod.hgm.mdws.gee <- inner_join(mdw.mod.dat,mdws_gee_dat, by=c("UCDID"="ID"))
write_rds(mod.hgm.mdws.gee,"./data_output/mod_hgm_mdw_GEE.rds")
rm(snmmc.mdws, wx.mdw.sub, mdws_gee_dat)

```

## Final Dataset

The Weixelman dataset originally selected **24** meadows, of which there were only 17 unique UCD Meadow IDs, as several of the meadows (`PLOTNAME2`) actually fall within the same UCD ID. In addition, the original Google Earth Engine (*GEE*) dataset that we used did not contain a number of the UCDID's, probably because that data wasn't able to be pulled via the GEE. Need to follow up with Andy on that.

```{r loadfinaldata, echo=F, eval=T}

mod.hgm.mdws.gee<- read_rds("./data_output/mod_hgm_mdw_GEE.rds")
wx.mdws<-read_csv(file = "./data_output/wx_mdw_sub_UCID.csv")
str(wx.mdws)

```

See below for stats. The final GEE dataset merged with Weixelman selected meadows gives us 9 meadows with unique UCDIDs. Fine for first cut of model. In comparing NDVI and NDWI, it appears only 5 HGM groups were retained, the subsurface HGM type didn't have any meadows selected and thus doesn't exist in this datase. See table for description of types from original through final GEE dataset.

```{r HGMtypes, eval=T, echo=F}
library(DT)

mdw_types<-c("lacustrine fringe", "depressional",
             "discharge-slope-hillslope",
             "riparian-discharge-slope", "riparian",
             "subsurface-discharge-slope",
             "subsurface", "dry")
mdw_type_code<-c("lf", "dep", "ds", "rip-ds",
                 "rip", "sub-ds", "sub", "dry")
mdw_type_class<-seq(1,8,1)

# bind df
mdw_hgms<-data.frame("hgm_type"=mdw_types,"hgm_code"=mdw_type_code, "hgm_class"=mdw_type_class )

DT::datatable(mdw_hgms, rownames = FALSE,
              class="compact row-border stripe",
              caption=htmltools::tags$caption(
                style = 'caption-side: bottom; text-align: center;',
                htmltools::em('Table 1. '), 
                htmltools::em('All HGM Types used from Weixelman et al. 2011')
              ), colnames = c("HGM Type"=1, "HGM Code"=2, "HGM Class"=3)
) %>% DT::formatStyle('HGM Type',  color = 'black', 
                  backgroundColor = 'lightblue', fontWeight = 'bold')

```

```{r hgmtypes_revised, eval=T, echo=F}

mdw_hgm_rev<-mdw_hgms[c(1:5,7),]
mdw_hgm_rev[6,3]<-6

# add counts of total meadows per group:
mod.hgm.mdws.gee  %>% distinct(UCDID,.keep_all = T) %>% group_by(hgm_class_comb)  %>% tally

mdw_hgm_rev$tot_mdws<-c(2,4,5,3,4,4)

DT::datatable(mdw_hgm_rev,rownames = FALSE,
              class="compact row-border stripe",
              caption=htmltools::tags$caption(
                style = 'caption-side: bottom; text-align: center;',
                htmltools::em('Table 2. '), 
                htmltools::em('Revised HGM Types for selection of meadows')
              ), colnames = c("HGM Type"=1, "HGM Code"=2, "HGM Class"=3, "Total Meadows"=4)
) %>% DT::formatStyle(columns = 'HGM Type',  color = 'black',fontWeight='bold') %>% 
  DT::formatStyle(columns = 'HGM Class',color = 'white', fontWeight = 'bold',
                  backgroundColor = styleInterval(cuts=c(1,2,3,4,5),
                                                  values = c("#440154FF", "#414487FF",
                                                             "#2A788EFF", "#22A884FF",
                                                             "#7AD151FF", "#FDE725FF")))

# this was when we didn't have subsurface meadows
# mdw_hgm_rev2<-mdw_hgm_rev[c(1:5),]
# DT::datatable(mdw_hgm_rev2,rownames = FALSE,
#               class="compact row-border stripe",
#               caption=htmltools::tags$caption(
#                 style = 'caption-side: bottom; text-align: center;',
#                 htmltools::em('Table 3. '), 
#                 htmltools::em('Revised HGM Types in final meadow dataset')
#               ), colnames = c("HGM Type"=1, "HGM Code"=2, "HGM Class"=3)
# ) %>% DT::formatStyle(columns = 'HGM Type',  color = 'black',fontWeight='bold') %>% 
#   DT::formatStyle(columns = 'HGM Class',color = 'white', fontWeight = 'bold',
#                   backgroundColor = styleInterval(cuts=c(1,2,3,4),
#                                                   values = c("#440154FF", "#3B528BFF",
#                                                              "#21908CFF", "#5DC863FF",
#                                                              "#FDE725FF")))
# 


```

```{r violin_plots, eval=T, echo=F}

mdw.dat<-read_rds("~/Documents/github/meadow_hgm_waterchem/data_output/mdw_mod_GEE.rds")
unique(mdw.dat$PLOTNAME2) # 16 unique plot names but only 9 unique IDs
unique(mdw.dat$UCDID) # 16 unique plot names but only 9 unique IDs

# Violin Plots -------

# make a violin plot of NDVI
vio.ndvi<-ggplot(data=mdw.dat[mdw.dat$index=="NDVI" & mdw.dat$month>=6 & mdw.dat$month<9,], 
       aes(x=as.factor(month), y=mean, fill=as.factor(hgm_class_comb))) + 
  ggtitle("A Plot of NDVI") + xlab("Month") + guides(fill=guide_legend(title="HGM Type")) +
  geom_violin() + scale_fill_viridis(discrete = T) + 
  theme_bw() #+ facet_grid(month~.)

# make a violin plot of NDWI
vio.ndwi<-ggplot(data=mdw.dat[mdw.dat$index=="NDWI" & mdw.dat$month>=6 & mdw.dat$month<9,], 
       aes(x=as.factor(month), y=mean, fill=as.factor(hgm_class_comb))) + 
  ggtitle("A Plot of NDWI") + xlab("Month") + guides(fill=guide_legend(title="HGM Type")) +
  geom_violin() + scale_fill_viridis(discrete = T) + 
  theme_bw() #+ facet_grid(month~.)

vio_stack<-cowplot::plot_grid(vio.ndvi, vio.ndwi, align = "v",nrow = 2)
vio_stack
#cowplot::save_plot("./fig_output/violin_ndvi_ndwi_jun-aug.png", plot = vio_stack, ncol = 2,base_aspect_ratio = 0.7, base_height = 6)
#![violinplots](../fig_output/violin_ndvi_ndwi_jun-aug.png)

```

```{r boxplots, eval=T, echo=F}

# Boxplots -------

# use notched boxplots to assess if medians are significantly different. Notches are used to compare groups; if the notches of two boxes do not overlap, this suggests that the medians are significantly different.

# make a box plot of NDVI
box.ndvi<-ggplot(data=mdw.dat[mdw.dat$index=="NDVI" & mdw.dat$month>=6 & mdw.dat$month<9,], 
       aes(x=as.factor(month), y=mean, fill=as.factor(hgm_class_comb))) + 
  ggtitle("Boxplot of NDVI") + xlab("Month") + guides(fill=guide_legend(title="HGM Type")) +
  geom_boxplot(notch = T) + scale_fill_viridis(discrete = T) + 
  theme_bw() #+ facet_grid(month~.)

# make a box plot of NDWI
box.ndwi<-ggplot(data=mdw.dat[mdw.dat$index=="NDWI" & mdw.dat$month>=6 & mdw.dat$month<9,], 
       aes(x=as.factor(month), y=mean, fill=as.factor(hgm_class_comb))) + 
  ggtitle("Boxplot of NDWI") + xlab("Month") + guides(fill=guide_legend(title="HGM Type")) +
  geom_boxplot(notch = T) + scale_fill_viridis(discrete = T) + 
  theme_bw() #+ facet_grid(month~.)

box_stack<-cowplot::plot_grid(box.ndvi, box.ndwi, align = "v",nrow = 2)

box_stack

#cowplot::save_plot("./fig_output/box_ndvi_ndwi_jun-aug.png", plot = box_stack, ncol = 2,base_aspect_ratio = 0.7, base_height = 6)

#![boxplots](../fig_output/box_ndvi_ndwi_jun-aug.png)

```

Use notched boxplots to assess if medians are significantly different. Notches are used to compare groups; if the notches of two boxes do not overlap, this suggests that the medians are significantly different.

### Plots by Water Year Type

Now that we have the data, we can also assess how these data may fluctuate across meadows and water year types. Below there are plots of Water Year Type and mean NDVI/NDWI for each HGM type. 

It appears there is some signal in the data during summer months, particularly for the `Lacustrine Fringe` and `Riparian` HGM types. The `Discharge Slope` appears to have a very large amount of variation inherently in all months across years (water year types), but model will hopefully help delineate if some of this variation can be explained by HGM types and landsat data.

```{r plots by WYT, eval=F, echo=F}

mdw.dat$SAC <- factor(mdw.dat$SAC, levels = c("W", "AN", "BN", "D", "C"))

# make a plot of NDWI
ggplot(data=mdw.dat[mdw.dat$index=="NDWI" & 
                      mdw.dat$month>5 & 
                      mdw.dat$month<9,], 
       aes(as.factor(month), mean, fill=as.factor(hgm_type))) + 
  ggtitle("A Plot of NDWI by Water Year Type") +
  geom_boxplot(notch = T) + scale_fill_viridis(direction = 1, discrete = T) +
  theme_bw() + facet_grid(SAC~.) + ylab("Mean") + xlab("Month")+
  guides(fill=guide_legend(title="HGM Type"))

ggplot(data=mdw.dat[mdw.dat$index=="NDVI" & 
                      mdw.dat$month>5 & 
                      mdw.dat$month<9,], 
       aes(as.factor(month), mean, fill=as.factor(hgm_code))) + 
  ggtitle("A Plot of NDVI by Water Year Type") +
  geom_boxplot(notch = T) + scale_fill_viridis(direction = 1, discrete = T) +
  theme_bw() + facet_grid(SAC~.) + ylab("Mean") + xlab("Month")+
  guides(fill=guide_legend(title="HGM Type"))


# look at trends across weeks and water years
ggplot() + geom_smooth(data=mdw.dat[mdw.dat$index=="NDVI" & 
                                      mdw.dat$month>5 & mdw.dat$month<9,], 
                       aes(x=wtyrwk, y=mean, color=hgm_class_comb))+
  geom_point(data=mdw.dat[mdw.dat$index=="NDVI" & mdw.dat$month>5 &
                            mdw.dat$month<9,], 
             aes(x=wtyrwk, y=mean, color=hgm_class_comb))+theme_bw()+
  scale_color_viridis(discrete = T) + facet_grid(SAC~.)

```

## Make a Shiny Map of Sites

```{r leaflet-mdws, message=F, echo=F}
library(leaflet)

m <- leaflet() %>% addTiles() %>% 
  #setView(lng = -120.8, lat = 39, zoom = 8) %>%  # set to Auburn/Colfax, zoom 5 for CA 
  addTiles(group = "OSM") %>%
  addProviderTiles("Stamen.TopOSMFeatures", group = "OSM Features") %>%
  addProviderTiles("Esri.WorldImagery", group = "ESRI Aerial") %>%
  addProviderTiles("Thunderforest.Landscape", group = "Topo") %>%
  hideGroup("OSM Features") %>% 
  

# proposed sites
  addCircleMarkers(data=wx.mdws, group="Weixelman Sites",
                   lng= ~LONG_DD, lat= ~LAT_DD,
                   popup=paste0("<b>Plot:</b> ", 
                                wx.mdws$PLOTNAME2, "<br>", "<b>HGM Type:</b> ",
                                wx.mdws$hgm_type, "<br>", "<b>UCD_ID:</b> ",
                                wx.mdws$UCDavisObject_ID, 
                                "<br>", "<b>Area_acres:</b> ",
                                wx.mdws$AREA_ACRE, "<br>", "<b>Elev_mean_m:</b> ",
                                wx.mdws$ELEV_MEAN),
                   stroke=TRUE, weight=0.6,radius=10,
                   fillOpacity = 0.8, color="black",
                   fillColor = "yellow") %>%
  
  # add controls for basemaps and data
  addLayersControl(
    baseGroups = c("OSM", "ESRI Aerial", "Topo"),
    overlayGroups = c("Weixelman Sites",
                      "OSM Features"),
    options = layersControlOptions(collapsed = T))

# Print Map
m

```

# Modeling

Make a simple mode of HGM type vs. WY and NDVI or NDWI, adjusting for individual meadows. Scale data first.

```{r make model dat, echo=T}

dff <- mod.hgm.mdws.gee

# Scale and center data:

# NDVI/NDWI
dff$lat_s<- (dff$LAT_DD - mean(dff$LAT_DD)) / sd(dff$LAT_DD)
dff$mdw_id<-coerce_index(dff$UCDID)

## NEED TO ADD WYTYPE TO THIS 
dff$wtyr_typ<-coerce_index(dff$SAC)
dff$wtyr_seq<-coerce_index(dff$WY)
dff$wtyrlag1<-dff$wtyr_seq-1 # lag 1 year
dff$hgm_class_comb <- coerce_index(dff$hgm_class_comb) # shift to numeric
dff$edgecomplex_s<-(dff$EDGE_COMPL - mean(dff$EDGE_COMPL)) / sd(dff$EDGE_COMPL)
dff$domrock<-coerce_index(as.factor(dff$DOM_ROCKTY)) # shift factor to numeric
dff$vegmaj<-coerce_index(as.factor(dff$VEG_MAJORI)) # shift factor to numeric
dff$kf_s<-(dff$Kf - mean(dff$Kf)) / sd(dff$Kf)
dff$claytotR_s<-(dff$ClayTot_r - mean(dff$ClayTot_r)) / sd(dff$ClayTot_r)
dff$soilcomp<-coerce_index(as.factor(dff$COMP_NAME)) # shift factor to numeric
dff$flow_slope_s<-(dff$FLOW_SLOPE - mean(dff$FLOW_SLOPE)) / sd(dff$FLOW_SLOPE)
dff$elevmean_s<- (dff$ELEV_MEAN - mean(dff$ELEV_MEAN)) / sd(dff$ELEV_MEAN)
dff$catch_s<- (dff$CATCHMENT_ - mean(dff$CATCHMENT_)) / sd(dff$CATCHMENT_)
dff$shapearea_s<- (dff$Shape_Area - mean(dff$Shape_Area)) / sd(dff$Shape_Area)
dff$flowrange_s<- (dff$FLOW_RANGE - mean(dff$FLOW_RANGE))/ sd(dff$FLOW_RANGE)

# select to ndvi data only
names(dff)

ndvi<-dff %>% filter(index=="NDVI", WY>=2000) %>% 
  select(UCDID, mdw_id, mean, wtyr_typ, wtyr_seq,
         hgm_class_comb, edgecomplex_s:flowrange_s)

names(ndvi)
summary(ndvi)

```

```{r setup model}

# make a list of names
# rename outcomes
dlist <- list(
  ndvi=ndvi$mean,
  mdwID=ndvi$mdw_id,
  wtyr_typ=ndvi$wtyr_typ,
  hgm = ndvi$hgm_class_comb # hgm ID
    #wtyr_seq=ndvi$wtyr_seq,
  #kf = ndvi$kf_s,
  #clay=ndvi$claytotR_s,
  #catcharea = ndvi$catch_s,
  #elev=ndvi$elevmean_s
)

# Mixed Effect Model with Varying Intercepts for Different HGM types

m1a<-map2stan(
  alist(
    ndvi ~ dnorm(mu,sigma),
    mu <- a + a_name + (b + b_name)*hgm,# + (b + b_name)*wtyr_typ,
    a ~ dnorm(0,100), # intercept
    b ~ dnorm(0,10), # slope
    c(a_name,b_name)[name] ~ dmvnorm2(0,sigma_name,Rho_name),
    sigma_name ~ dcauchy(0,1),
    Rho_name ~ dlkjcorr(2),
    sigma ~ dcauchy(0,1)),
  data=dlist, iter=1000, chains=2,cores=2)

# look at estimates omitting varying effects output
precis( m1a , depth=2 ,
    pars=c("a","b","sigma_name","Rho_name") )

# rhats should be 1 or 1.00, and mean and STD should make sense (not wildly variable all over map). Correlations between slope and intercept (Rho_name 1,2 or vice versa) should potentially make sense too.


#summary(m1a)
plot(m1a)
par(mfrow=c(1,1))
plot(precis(m1a))
precis(m1a)
plot(precis(m1a, depth=2))
mtext("Varying effects model")
postcheck(m1a)

```





