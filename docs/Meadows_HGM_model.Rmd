---
title: "NDVI-HGM-WQ Model"
author: "Ryan Peek"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output:
 html_document:
   highlight: pygments
   theme: yeti
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load-libs, echo=FALSE}
suppressPackageStartupMessages({
  library(dplyr)
	library(ggplot2)
  library(viridis)
	library(ggthemes)
  library(lubridate)
	library(leaflet)
  library(readr)
  #library(quickmapr)
  library(rethinking)
  library(rgdal)
  library(DT)
  #library(ggrepel)
  })

# snmmc.mdws<-read_rds("./data_output/UCD_mdw_df.rds") # UCD Dataset for 17,039 meadows

#mod.hgm.mdws.gee<- read_rds("../data_output/mod_hgm_mdw_GEE.rds")

```

## Data Filtering and Merging

Take original data from previous and munge and merge with updated Dave Weixelman meadows that were selected.

```{r munge-orig-data, eval=F, echo=F}

wx.mdw<-read_rds("./data_output/wx_mdw_dat.rds") # weixelman data for 114 meadows

# rename and sort columns a bit
# Drop HGM source_type 8 (Dry), and combine classes 6 and 7, add elev col

wx.mdw <- wx.mdw %>% 
  select(PLOT, UCDavisObject_ID:PLOTNAME2, AREA_ACRE:Shape_Area) %>% 
  rename(Method=METHOD.y, UCDID=UCDavisObject_ID) %>% 
  mutate(hgm_class_comb = ifelse(source_type==8, NA, source_type), 
         hgm_class_comb = ifelse(source_type==7, 6, hgm_class_comb),
         elev_av_2100 = ifelse(ELEV_MEAN<2100, "<2100",">=2100"))

## make a quick meadows type table
mdw_types<-c("lacustrine fringe", "depressional",
             "discharge-slope-hillslope",
             "riparian-discharge-slope", "riparian",
             "subsurface-discharge-slope",
             "subsurface", "dry")
mdw_type_code<-c("lf", "dep", "ds", "rip-ds",
                 "rip", "sub-ds", "sub", "dry")
mdw_type_class<-seq(1,8,1)

# bind df
mdw_hgms<-data.frame("hgm_type"=mdw_types,"hgm_code"=mdw_type_code, "hgm_class"=mdw_type_class )

# now join this with original dataset
wx.mdw2<-inner_join(wx.mdw, mdw_hgms, by=c("source_type"="hgm_class"))
head(as.data.frame(wx.mdw2[,c(2,14,16,44:47)]))

# save for easy reload next time:
# write_rds(x = wx.mdw2, path ="~/Documents/github/meadow_hgm_waterchem/data_output/wx_mdw_dat2.rds")

```

First filter data to only selected data (`OK` and not `DRY` or `NOT OK`) based on Dave Weixelman's excel file from **June 05, 2016**. Several meadows were not accessible and were dropped, final list only includes data where there were UCDSNM_ID matched. Second, recombine and drop HGM classes (*drop dry category `8` and merge `6 & 7`*). Finally write back out as *.rds* file.

```{r load revised data, eval=F, echo=F}

wx.mdw<-read_rds("./data_output/wx_mdw_dat2.rds")

# this is the updated data version: 
wx.mdw.sub<-read_csv("./data/water_source_MDW_selection_2016_10_07.csv")
head(wx.mdw.sub)
wx.mdw.sub %>% ggplot + aes(x=hgm_classes, fill=elev_av_2100) + geom_bar()

# filter out the "NOT OK" and select cols of interest:
wx.mdw.sub <- wx.mdw.sub %>% 
  mutate(selected=1)
wx.mdw.sub %>% tally(selected) # should be 33 here!

# keep only selected and see how many matches occur:
dim(inner_join(wx.mdw, wx.mdw.sub, by="PLOT"))  # only 19 match up!
dim(inner_join(wx.mdw, wx.mdw.sub, by=c("UCDID"="UCDavisObject_ID")))  # 24 match up!
dim(merge(wx.mdw, wx.mdw.sub, by.x="UCDID", by.y="UCDavisObject_ID", all.y=T))

# this is the refiltered data...based on Dave's comments. Re-merge with dataset
wx.mdw.sub.UCID<-left_join(wx.mdw.sub, wx.mdw, by=c("UCDavisObject_ID"="UCDID")) %>% 
  distinct(UCDavisObject_ID,.keep_all = T) %>% 
  select(-ends_with(".y"), -c(STATE:Shape_Area)) %>% 
  rename_(.dots=setNames(names(.), gsub("\\.x", "", names(.))))

names(wx.mdw.sub.UCID)
summary(wx.mdw.sub.UCID)

# write to CSV and fill in blanks:
write_csv(wx.mdw.sub.UCID, path = "./data_output/wx_mdw_sub_UCID.csv")
# ok write this out to merge with GEE data later
# write_rds(x = wx.mdw.sub.UCID, path ="~/Documents/github/meadow_hgm_waterchem/data_output/wx_mdw_sub_UCDID.rds")
```

### Merge with Google Earth Engine Data

Need to merge with original GEE data after removing duplicated columns, then filter, rename a col, and save out.

```{r GEE clean and merge, eval=F, echo=F}
# HGM data ----
wx.mdw.sub<-read_csv(file = "./data_output/wx_mdw_sub_UCID.csv")
str(wx.mdw.sub)

# Make a list of duplicated column names (from SNMMC data) to filter from merge:
wx<-names(wx.mdw.sub)
gee<-names(snmmc.mdws)
allcols<-c(wx, gee)
col.dups <- allcols[duplicated(allcols)]

# now select columns that aren't duplicated before merging
library(magrittr) # to allow for special pipes %<>%
wx.mdw.sub %<>% select(-one_of(col.dups)) # writes back to same object
names(wx.mdw.sub)

# merge with GEE data
mdw.mod.dat<-inner_join(wx.mdw.sub, snmmc.mdws, by=c("UCDavisObject_ID"="ID"))
mdw.mod.dat %<>% select(-HGM_TYPE) %>%  dplyr::rename(., UCDID = UCDavisObject_ID)
names(mdw.mod.dat) # 47 variables, complete dataset

unique(mdw.mod.dat$UCDID) # should have 22!

## GET GEE DATA AND BIND NDVI w NDWI ------

folder='raw/'
get_csv <- list.files(folder, pattern = "*.csv")

mdws_gee <- data.frame()
for(i in 1:length(get_csv)) {
  csv<-read.csv(paste(folder,get_csv[i], sep=""), colClasses = "character")
  mdws_gee<-rbind(csv, mdws_gee)
  rm(csv)
  }

# Now Clean Up Rows
source(file='./scripts/functions/gee_data_cleanup.R')
# clean up df
mdws_gee_dat <- gee_tidy_df(mdws_gee)

#write_rds(mdws_gee_dat, path="./data_output/hgm_mdws_gee_dat.rds")
#mdws_gee_dat<-read_rds(path="./data_output/hgm_mdws_gee_dat.rds")

# remove temporary data
rm(mdws_gee)

## Filter and Join Mdws ------
mod.hgm.mdws.gee <- inner_join(mdw.mod.dat,mdws_gee_dat, by=c("UCDID"="ID"))
write_rds(mod.hgm.mdws.gee,"./data_output/mod_hgm_mdw_GEE.rds")
rm(snmmc.mdws, wx.mdw.sub, mdws_gee_dat)

```

### Final Dataset

The Weixelman dataset originally selected **24** meadows, of which there were only 17 unique UCD Meadow IDs, as several of the meadows (`PLOTNAME2`) actually fall within the same UCD ID. Merged these meadows with the NFWF Meadows to get final dataset, and am including some of the Kern high elevation sites (which are probably very difficult to visit, so may need to drop in future).

```{r get_water_year, eval=F, echo=F}

mod.hgm.mdws.gee<- read_rds("./data_output/mod_hgm_mdw_GEE.rds")
wx.mdws<-read_csv(file = "./data_output/wx_mdw_sub_UCID.csv")
str(wx.mdws)

# Add Water Year Cols
source("./scripts/functions/doy.R")

mod.hgm.mdws.gee$date<-ymd(mod.hgm.mdws.gee$date)
mod.hgm.mdws.gee$WY<-wtr_yr(mod.hgm.mdws.gee$date)
mod.hgm.mdws.gee$DOWY<-dowy(mod.hgm.mdws.gee$date)
mod.hgm.mdws.gee$DOY<-yday(mod.hgm.mdws.gee$date)
summary(mod.hgm.mdws.gee)

## GET SPATIAL DWR REGIONS FOR EACH MEADOW

dwr<- readOGR("./data/shps/DWR_HydrologicRegions-utm11.shp", layer="DWR_HydrologicRegions-utm11", verbose = F)
proj4string(dwr)

# Set Projection
wgs84<-CRS("+init=epsg:4326")
nad83<-CRS("+init=epsg:4269")
dwr<-spTransform(dwr, wgs84) # reproject
proj4string(dwr) # double check

# Get Attribute of DWR Polygon
library(dismo)
library(sp)

# make spatial dataframe of selected lat longs
xy <- mod.hgm.mdws.gee %>% distinct(UCDID, .keep_all = T) %>%
  dplyr::select(UCDID, LAT_DD, LONG_DD) 

xy.sp <- SpatialPoints(coords = xy[,c("LONG_DD", "LAT_DD")], proj4string = wgs84)
spdf.sp <- SpatialPointsDataFrame(xy.sp, xy)
str(spdf.sp)

# plot(dwr) # this is slow
# plot(spdf.sp, cex=2, col="red", pch=16, add=T) # this is slow

xy.over<-cbind(xy, over(spdf.sp, dwr[,4:5]))
#write_rds(xy.over, "./data_output/mdw_pts_w_dwr_region.rds")


xy.over <- read_rds("./data_output/mdw_pts_w_dwr_region.rds")
xy.over

## SO JUST COMBINE TO NORTH/SOUTH FOR NOW. GET TULARE DATA LATER
# South Lahontan/Tulare/: Use San Joaquin
# North Lahontan: Use Sacramento
xy.dwr <- xy.over %>% 
  mutate(dwr_name=ifelse(as.numeric(HR_CODE)==9 |
                           as.numeric(HR_CODE)==7, "SJR", "SAC"),
         dwr_code=ifelse(dwr_name=="SJR", 06, 05))
xy.dwr <- xy.dwr %>% dplyr::select(UCDID, HR_CODE:dwr_code)

# join this with full data set
mod.hgm <- inner_join(mod.hgm.mdws.gee, xy.dwr, by="UCDID")
names(mod.hgm)

## Add WYT
wy <- read.csv("./data/wy_type.csv")
wy <- dplyr::select(wy, WY, SAC_Index, SAC_maf_WYsum, SAC, SJ_maf_WYsum, SJ_Index, SJ)
head(wy)

## MERGE WITH FINAL DATA
mod.hgm <- inner_join(mod.hgm, wy, by="WY") # trims out 2016 b/c WY only to 2015

names(mod.hgm)

#write_rds(mod.hgm, path="./data_output/hgm_gee_mdws_dat.rds")

```

The final GEE dataset merged with Weixelman selected meadows gives us 22 meadows with unique UCDIDs, including 5 of the NFWF Meadows. See Table below for first few rows of dataset to see all variables.

```{r final dataset, eval=T, echo=T}

mod.hgm<-read_rds(path="./data_output/hgm_gee_mdws_dat.rds")
#names(mod.hgm)
datatable(head(as.data.frame(mod.hgm)), 
              class="compact row-border stripe",
              caption=htmltools::tags$caption(
                style = 'caption-side: bottom; text-align: left;',
                htmltools::em('Table 1. '), 
                htmltools::em('First Few Rows of All Data Used for Model')))

```

#### HGM Types

The HGM Types were collapsed from the initial 8 to a final 6 types. See *Table 2 through Table 4* below for more information on the meadow HGM types, and which meadows were selected (by HGM type). 

```{r HGMtypes, eval=T, echo=F}
library(DT)

mdw_types<-c("lacustrine fringe", "depressional",
             "discharge-slope-hillslope",
             "riparian-discharge-slope", "riparian",
             "subsurface-discharge-slope",
             "subsurface", "dry")
mdw_type_code<-c("lf", "dep", "ds", "rip-ds",
                 "rip", "sub-ds", "sub", "dry")
mdw_type_class<-seq(1,8,1)

# bind df
mdw_hgms<-data.frame("hgm_type"=mdw_types,"hgm_code"=mdw_type_code, "hgm_class"=mdw_type_class )

DT::datatable(mdw_hgms, rownames = FALSE,
              class="compact row-border stripe",
              caption=htmltools::tags$caption(
                style = 'caption-side: bottom; text-align: center;',
                htmltools::em('Table 2. '), 
                htmltools::em('All HGM Types used from Weixelman et al. 2011')
              ), colnames = c("HGM Type"=1, "HGM Code"=2, "HGM Class"=3)
) %>% DT::formatStyle('HGM Type',  color = 'black', 
                  backgroundColor = 'lightblue', fontWeight = 'bold')

```

```{r hgmtypes_revised, eval=F, echo=F}

mdw_hgm_rev<-mdw_hgms[c(1:5,7),]
mdw_hgm_rev[6,3]<-6

# add counts of total meadows per group:
# mod.hgm  %>% distinct(UCDID,.keep_all = T) %>% group_by(hgm_class_comb)  %>% tally

mdw_hgm_rev$tot_mdws<-c(2,4,5,3,4,4)

# Table of HGM Types and Total Meadows per Type
DT::datatable(mdw_hgm_rev,rownames = FALSE,
              class="compact row-border stripe",
              caption=htmltools::tags$caption(
                style = 'caption-side: bottom; text-align: center;',
                htmltools::em('Table 3. '), 
                htmltools::em('Revised HGM Types for selection of meadows')
              ), colnames = c("HGM Type"=1, "HGM Class"=2, "HGM Code"=3, "Total Meadows"=4)
) %>% formatStyle(columns = 'HGM Type',  color = 'black',fontWeight='bold') %>% 
  formatStyle(columns = 'HGM Code',color = 'gray', fontWeight = 'bold',
                  backgroundColor = styleInterval(cuts=c(1,2,3,4,5),
                                                  values = c("#440154",
                                                             "#414487",
                                                             "#2a788e",
                                                             "#22a884",
                                                             "#7ad151",
                                                             "#fde725")))
```

## Plots

Finally, let's look at the data. This is NDVI and NDWI across 22 meadows for each HGM type for 3 months. Remember this is 30+ years (1984-2015) of 8-day LANDSAT composites, so distributions are very large. The total dataset is over 50,000 observations.

### Violin Plots

Violin plots are essentially boxplots showing densities or distributions over the data groups. Hard to interpret too much from these, but easier to understand the distribution of the data for each of these groupings (*HGM type and Month*) over all years (1984-2015).

```{r violin_plots, eval=F, echo=T}

mod.hgm$month <- month(mod.hgm$date)

# Violin Plots -------

# make a violin plot of NDVI
vio.ndvi<-ggplot(data=mod.hgm[mod.hgm$index=="NDVI" & mod.hgm$month>=6 & mod.hgm$month<9,], 
       aes(x=as.factor(month), y=mean, fill=as.factor(hgm_class_comb))) + 
  ggtitle("A Plot of NDVI") + xlab("Month") + guides(fill=guide_legend(title="HGM Type")) +
  geom_violin() + scale_fill_viridis(discrete = T) + 
  theme_bw() #+ facet_grid(month~.)

# make a violin plot of NDWI
vio.ndwi<-ggplot(data=mod.hgm[mod.hgm$index=="NDWI" & mod.hgm$month>=6 & mod.hgm$month<9,], 
       aes(x=as.factor(month), y=mean, fill=as.factor(hgm_class_comb))) + 
  ggtitle("A Plot of NDWI") + xlab("Month") + guides(fill=guide_legend(title="HGM Type")) +
  geom_violin() + scale_fill_viridis(discrete = T) + 
  theme_bw() #+ facet_grid(month~.)

vio_stack<-cowplot::plot_grid(vio.ndvi, vio.ndwi, align = "v",nrow = 2)
vio_stack

cowplot::save_plot("./fig_output/violin_ndvi_ndwi_jun-aug.png", plot = vio_stack, ncol = 2,base_aspect_ratio = 0.7, base_height = 6)


```

![violinplots](../fig_output/violin_ndvi_ndwi_jun-aug.png)

### Boxplots

 Here are the same data (MEANS of LANDSAT DATA) with the same groupings using notched boxplots to assess if medians are significantly different. Notches are used to compare groups; if the notches of two boxes do not overlap, this suggests that the medians are significantly different.

```{r boxplots, eval=F, echo=T}

# Boxplots -------

# make a box plot of NDVI
box.ndvi<-ggplot(data=mod.hgm[mod.hgm$index=="NDVI" & mod.hgm$month>=6 & mod.hgm$month<9,], 
       aes(x=as.factor(month), y=mean, fill=as.factor(hgm_code))) + ylim(c(-0.2,1))+
  ggtitle("Boxplot of NDVI") + xlab("Month") + guides(fill=guide_legend(title="HGM Type")) +
  geom_boxplot(notch = T) + scale_fill_viridis(discrete = T) + 
  theme_bw() #+ facet_grid(month~.)

# make a box plot of NDWI
box.ndwi<-ggplot(data=mod.hgm[mod.hgm$index=="NDWI" & mod.hgm$month>=6 & mod.hgm$month<9,], 
       aes(x=as.factor(month), y=mean, fill=as.factor(hgm_code))) + ylim(c(-0.2,1))+
  ggtitle("Boxplot of NDWI") + xlab("Month") + guides(fill=guide_legend(title="HGM Type")) +
  geom_boxplot(notch = T) + scale_fill_viridis(discrete = T) + 
  theme_bw() #+ facet_grid(month~.)

box_stack<-cowplot::plot_grid(box.ndvi, box.ndwi, align = "v",nrow = 2)

box_stack

cowplot::save_plot("./fig_output/box_ndvi_ndwi_jun-aug.png", plot = box_stack, ncol = 2,base_aspect_ratio = 0.7, base_height = 6)

```

![boxplots](../fig_output/box_ndvi_ndwi_jun-aug.png)

In this case, it's interesting that the NDVI seems to parse HGM types out more significantly than the NDWI data, with the exception of the *subsurface* and *subsurface-discharge slope* types, which seem to be more clearly different than anything else in the NDWI data. 

### Plots by Water Year Type

Now that we have the data, we can also assess how these data may fluctuate across meadows and water year types. See figures below of Water Year Type and mean NDVI/NDWI for each HGM type. 

It appears there is some signal in the data during summer months, particularly for the `Lacustrine Fringe` and `Riparian` HGM types. The `Discharge Slope` appears to have a very large amount of variation inherently in all months across years (water year types), but model will hopefully help delineate if some of this variation can be explained by HGM types and landsat data.

```{r plots by WYT, eval=F, echo=F, fig.height=4, fig.width=5}

# Relevel the Water Year Type into appropriate order:
mod.hgm$SAC <- factor(mod.hgm$SAC, levels = c("W", "AN", "BN", "D", "C"))
mod.hgm$SJ <- factor(mod.hgm$SJ, levels = c("W", "AN", "BN", "D", "C"))

# make a plot of NDWI
ggplot(data=mod.hgm[mod.hgm$index=="NDWI" & 
                      mod.hgm$month>5 & 
                      mod.hgm$month<9,], 
       aes(as.factor(month), mean, fill=as.factor(hgm_type))) + 
  ggtitle("A Plot of NDWI by Water Year Type") + ylim(c(-0.1,0.8)) +
  geom_boxplot(notch = T) + scale_fill_viridis(direction = 1, discrete = T) +
  theme_bw() + facet_grid(SAC~.) + ylab("Mean") + xlab("Month")+
  guides(fill=guide_legend(title="HGM Type"))

ggplot(data=mod.hgm[mod.hgm$index=="NDVI" & 
                      mod.hgm$month>5 & 
                      mod.hgm$month<9,], 
       aes(as.factor(month), mean, fill=as.factor(hgm_code))) + 
  ggtitle("A Plot of NDVI by Water Year Type") + ylim(c(-0.1,0.8)) +
  geom_boxplot(notch = T) + scale_fill_viridis(direction = 1, discrete = T) +
  theme_bw() + facet_grid(SAC~.) + ylab("Mean") + xlab("Month")+
  guides(fill=guide_legend(title="HGM Type"))


# look at trends across weeks and water years
ggplot() + geom_smooth(data=mod.hgm[mod.hgm$index=="NDVI" & 
                                      mod.hgm$month>5 & mod.hgm$month<9,], 
                       aes(x=DOWY, y=mean, color=hgm_code), se=F)+
  geom_point(data=mod.hgm[mod.hgm$index=="NDVI" & mod.hgm$month>5 &
                            mod.hgm$month<9,], 
             aes(x=DOWY, y=mean, color=hgm_code))+
  guides(color=guide_legend(title="HGM Type"))+
  theme_bw()+ xlab("Water Year Day (June 1 through June 30)") +
  scale_color_viridis(discrete = T) + facet_grid(SAC~.)

```

## Make a Shiny Map of Sites

```{r leaflet-mdws, message=F, echo=F}
library(leaflet)

wx.mdws<-read_csv(file = "../data_output/wx_mdw_sub_UCID.csv")

m <- leaflet() %>% addTiles() %>% 
  #setView(lng = -120.8, lat = 39, zoom = 8) %>%  # set to Auburn/Colfax, zoom 5 for CA 
  addTiles(group = "OSM") %>%
  addProviderTiles("Stamen.TopOSMFeatures", group = "OSM Features") %>%
  addProviderTiles("Esri.WorldImagery", group = "ESRI Aerial") %>%
  addProviderTiles("Thunderforest.Landscape", group = "Topo") %>%
  hideGroup("OSM Features") %>% 
  

# proposed sites
  addCircleMarkers(data=wx.mdws, group="Weixelman Sites",
                   lng= ~LONG_DD, lat= ~LAT_DD,
                   popup=paste0("<b>Plot:</b> ", 
                                wx.mdws$PLOTNAME2, "<br>", "<b>HGM Type:</b> ",
                                wx.mdws$hgm_type, "<br>", "<b>UCD_ID:</b> ",
                                wx.mdws$UCDavisObject_ID, 
                                "<br>", "<b>Area_acres:</b> ",
                                wx.mdws$AREA_ACRE, "<br>", "<b>Elev_mean_m:</b> ",
                                wx.mdws$ELEV_MEAN),
                   stroke=TRUE, weight=0.6,radius=10,
                   fillOpacity = 0.8, color="black",
                   fillColor = "yellow") %>%
  
  # add controls for basemaps and data
  addLayersControl(
    baseGroups = c("OSM", "ESRI Aerial", "Topo"),
    overlayGroups = c("Weixelman Sites",
                      "OSM Features"),
    options = layersControlOptions(collapsed = T))

# Print Map
m

```

# Modeling

Make a simple mode of HGM type vs. WY and NDVI or NDWI, adjusting for individual meadows. Scale data first.

```{r scale model data, eval=F, echo=T}

# Scale Data
dff <- mod.hgm
names(dff)

# add month and WY column for modeling (combines both SAC and SJ based on location)
dff$month<-month(dff$date)
dff$dwr_name <- as.factor(dff$dwr_name)
dff$wyi <- ifelse(dff$dwr_name == "SAC", dff$SAC_Index, dff$SJ_Index)
summary(dff)

# Scale and center data:
dff$lf_s<- (dff$LF - mean(dff$LF)) / sd(dff$LF)
dff$rip_s<- (dff$Riparian - mean(dff$Riparian)) / sd(dff$Riparian)
dff$sub_s<- (dff$Subsurface - mean(dff$Subsurface)) / sd(dff$Subsurface)
dff$ds_s<- (dff$DS - mean(dff$DS)) / sd(dff$DS)
dff$dep_s<- (dff$Depressional - mean(dff$Depressional)) / sd(dff$Depressional)
dff$dry_s<- (dff$Dry - mean(dff$Dry)) / sd(dff$Dry)
dff$lat_s<- (dff$LAT_DD - mean(dff$LAT_DD)) / sd(dff$LAT_DD)
dff$mdw_id<-coerce_index(dff$UCDID)
dff$wyi_s<-(dff$wyi - mean(dff$wyi)) / sd(dff$wyi)
dff$edgecomplex_s<-(dff$EDGE_COMPL - mean(dff$EDGE_COMPL)) / sd(dff$EDGE_COMPL)
dff$domrock<-coerce_index(as.factor(dff$DOM_ROCKTY)) # shift factor to numeric
dff$vegmaj<-coerce_index(as.factor(dff$VEG_MAJORI)) # shift factor to numeric
dff$kf_s<-(dff$Kf - mean(dff$Kf)) / sd(dff$Kf)
dff$claytotR_s<-(dff$ClayTot_r - mean(dff$ClayTot_r)) / sd(dff$ClayTot_r)
dff$soilcomp<-coerce_index(as.factor(dff$COMP_NAME)) 
dff$flow_slope_s<-(dff$FLOW_SLOPE - mean(dff$FLOW_SLOPE)) / sd(dff$FLOW_SLOPE)
dff$elevmean_s<- (dff$ELEV_MEAN - mean(dff$ELEV_MEAN)) / sd(dff$ELEV_MEAN)
dff$catch_s<- (dff$CATCHMENT_ - mean(dff$CATCHMENT_)) / sd(dff$CATCHMENT_)
dff$shapearea_s<- (dff$Shape_Area - mean(dff$Shape_Area)) / sd(dff$Shape_Area)
dff$flowrange_s<- (dff$FLOW_RANGE - mean(dff$FLOW_RANGE))/ sd(dff$FLOW_RANGE)

# Look at Columns
names(dff)
dff %>% filter(index=="NDWI", month==8) %>% tally # count records for ndwi
dff %>% filter(index=="NDVI", month==8) %>% tally

# add month col and select max months
dfVI <- dff %>% 
  group_by(UCDID, WY, month) %>% 
  filter(index=="NDVI", month==8, mean==max(mean, na.rm=T)) %>%
  select(UCDID, mdw_id, WY, month, mean, hgm_class_comb, lf_s:lat_s,
         wyi_s:flowrange_s,LF:Depressional)
  
dfWI <- dff %>% 
  group_by(UCDID, WY, month) %>% 
  filter(index=="NDWI", month==8) %>% 
  filter(mean==max(mean)) %>%
  select(UCDID, mdw_id, WY, month, mean, hgm_class_comb, lf_s:lat_s,
         wyi_s:flowrange_s,LF:Depressional)

# make the datasets the same size for model comparison later:
dfWI<-dfWI[-sample(nrow(dfVI),13),]

save(dff, dfVI, dfWI, file = "./data_output/model_datasets_Aug_max.rda") 

```

```{r load mod datasets, eval=T, echo=F}
# Full Dataset
mod.hgm<-read_rds(path="./data_output/hgm_gee_mdws_dat.rds")

# Model Datasets
load("./data_output/model_datasets_Aug_max.rda")

# NDVI
names(dfVI)
summary(dfVI)

dfVI<-as.data.frame(dfVI)
dfWI<-as.data.frame(dfWI)

# make a list of name (rename outcomes)
dlist1 <- list(
  ndvi=dfVI$mean,
  mdwID=dfVI$mdw_id,
  WY=(dfVI$WY - mean(dfVI$WY)) / sd(dfVI$WY),
  wyi=dfVI$wyi_s,
  rip=dfVI$rip_s,
  lf=dfVI$lf_s,
  sub=dfVI$sub_s,
  ds=dfVI$ds_s,
  dep=dfVI$dep_s,
  hgm = dfVI$hgm_class_comb, # hgm ID
  lat=dfVI$lat_s,
  kf = dfVI$kf_s,
  clay=dfVI$claytotR_s,
  catcharea = dfVI$catch_s,
  shape=dfVI$shapearea_s,
  flowslope=dfVI$flow_slope_s,
  elev=dfVI$elevmean_s
)

# NDWI
names(dfWI)

# make a list of name (rename outcomes)
dlist2 <- list(
  ndwi=dfWI$mean,
  mdwID=dfWI$mdw_id,
  WY=(dfWI$WY - mean(dfWI$WY)) / sd(dfWI$WY),
  wyi=dfWI$wyi_s,
  rip=dfWI$rip_s,
  lf=dfWI$lf_s,
  sub=dfWI$sub_s,
  ds=dfWI$ds_s,
  dep=dfWI$dep_s,
  hgm=dfWI$hgm_class_comb, # hgm ID
  lat=dfWI$lat_s,
  kf = dfWI$kf_s,
  clay=dfWI$claytotR_s,
  catcharea = dfWI$catch_s,
  shape=dfWI$shapearea_s,
  flowslope=dfWI$flow_slope_s,
  elev=dfWI$elevmean_s
)

```

```{r table of selected mdws, eval=T, echo=F}
library(tidyr)
library(magrittr)
library(dplyr)

# Table of Each Meadow and HGM Type for that Meadow
DT::datatable(mod.hgm %>% dplyr::distinct(PLOTNAME2, .keep_all = T) %>% select(UCDID,PLOTNAME2, hgm_type, hgm_class_comb), 
              rownames = TRUE,
              class="compact row-border stripe",
              caption=htmltools::tags$caption(
                style = 'caption-side: bottom; text-align: center;',
                htmltools::em('Table 4. '), 
                htmltools::em('Selected Meadows for HGM-LANDSAT Model')),
              colnames = c("RowID"=1, "UCD_ID"=2,"Plot Name"=3,"HGM Type"=4, "HGM Code"=5)) %>%
  DT::formatStyle(columns = 'HGM Code',color = 'white', fontWeight = 'bold',
                  backgroundColor = styleInterval(cuts=c(1,2,3,4,5),
                                                  values = c('#440154', 
                                                             '#414487',
                                                             '#2A788E', 
                                                             '#22A884',
                                                             '#7AD151',
                                                             '#FDE725'))
  )

```

## Single Intercept Model 

Using Meadow ID as the intercept across each HGM type (as a scaled/centered proportion).

```{r mod_hgm_only, eval=F, echo=T}

# START SIMPLE: model of HGM types (proportion per type per meadow)
# and WY index values

m1a <- map2stan(
  alist(
    ndvi ~ dnorm(mu, sigma), 
    mu <- a + a_mdwID[mdwID] + bwyi*wyi + brip*rip + blf*lf + 
      bsub*sub + bds*ds + bdep*dep,
    a ~ dnorm(0,100),
    a_mdwID[mdwID] ~ dnorm(0,sigma),
    c(bwyi, brip, bsub, bds, bdep, blf) ~ dnorm(0,10),
    sigma ~ cauchy(0,3)
  ),
  data=dlist1, chains = 2, iter=5000, cores=4)

m2a <- map2stan(
  alist(
    ndwi ~ dnorm(mu, sigma), 
    mu <- a + a_mdwID[mdwID] + bwyi*wyi + brip*rip + blf*lf + 
      bsub*sub + bds*ds + bdep*dep,
    a ~ dnorm(0,100),
    a_mdwID[mdwID] ~ dnorm(0,sigma),
    c(bwyi, brip, bsub, bds, bdep, blf) ~ dnorm(0,10),
    sigma ~ cauchy(0,3)
  ),
  data=dlist2, chains = 2, iter=5000, cores=4)

# SAVE THEM
save(m1a, m2a, file = "./data_output/models_1a_1b_revised.rda")

# look at estimates omitting varying effects output
precis( m1a , depth=2)
precis( m2a , depth=2)
# rhats should be 1 or 1.00, and mean and STD should make sense (not wildly variable all over map).

plot(m1a) # see trace plots, look good.
plot(m2a) # see trace plots, look good.

par(mfrow=c(1,1)) # clear the plots

## MOD 1A
png(filename = "./fig_output/m1a_precis.png", width = 9, height = 6.6, units = "in", res = 200)
plot(precis(m1a)) # see basic results with fixed effects
mtext("Varying effects (Mdws) model NDVI")
dev.off()

png(filename = "./fig_output/m1a_precis_all.png", width = 9, height = 6.6, units = "in", res = 200)
plot(precis(m1a, depth=2)) # see full results for each meadow
mtext("Varying effects model (Mdws) NDVI")
dev.off()

## MOD 2A
png(filename = "./fig_output/m2a_precis.png", width = 9, height = 6.6, units = "in", res = 200)
plot(precis(m2a)) # see basic results with fixed effects
mtext("Varying effects (Mdws) model NDWI")
dev.off()

png(filename = "./fig_output/m2a_precis_all.png", width = 9, height = 6.6, units = "in", res = 200)
plot(precis(m2a, depth=2)) # see full results for each meadow
mtext("Varying effects model (Mdws) NDWI")
dev.off()

compare(m1a, m2a)
load(file = "./data_output/models_1a_1b_revised.rda")
#abline(v = 1, col=col.alpha("gray",0.5))

## EXTRACT POSTERIORS
post1a<-extract.samples(m1a)
post2a<-extract.samples(m2a)

## Plot Densities M1A
dens(post1a$a_mdwID, xlim=c(-0.5, 1), 
     ylim=c(0,20), lty=2, show.HPDI = T)
#dens(post1a$a, col="red", show.HPDI = F, add=T, lwd=1.5)
#dens(post1a$bwyi, col="forestgreen", show.HPDI = T, add=T)
dens(post1a$brip, col="green", show.HPDI = T, lwd=1.5, add=T)
dens(post1a$bds, col="tan", show.HPDI = F, lwd=1.5, add=T)
dens(post1a$bdep, col="darkblue", show.HPDI = F, lwd=1.5, add=T)
dens(post1a$blf, col="coral2", show.HPDI = F, lwd=1.5, add=T)
dens(post1a$bsub, col="purple", show.HPDI = F, add=T, lwd=3)
dens(post1a$sigma, col="red", show.HPDI = F, add=T, lwd=1, lty=2)

## Plot Densities M2A
dens(post2a$a_mdwID, xlim=c(-0.5, 1), 
     ylim=c(0,12), lty=2, show.HPDI = T)
#dens(post1a$a, col="red", show.HPDI = F, add=T, lwd=1.5)
#dens(post1a$bwyi, col="forestgreen", show.HPDI = T, add=T)
dens(post2a$brip, col="green", show.HPDI = T, lwd=1.5, add=T)
dens(post2a$bds, col="tan", show.HPDI = F, lwd=1.5, add=T)
dens(post2a$bdep, col="darkblue", show.HPDI = F, lwd=1.5, add=T)
dens(post2a$blf, col="coral2", show.HPDI = F, lwd=1.5, add=T)
dens(post2a$bsub, col="purple", show.HPDI = F, add=T, lwd=3)

```

## Multi-level Model

Add different "actor" (so have two variables with changing intercepts). See page 376 in McElreath's book. Nice comparison of the two different sigmas (in this case it would be mdwID and hgm), to show one was stronger than other but including both doesn't add all that much (or detract much) from the model.

Using Meadow ID and HGM category as the intercepts across each HGM type (as a scaled/centered proportion).


```{r multintercept, eval=T, echo=T}

m1b <- map2stan(
  alist(
    ndvi ~ dnorm(mu, sigma), 
    mu <- a + a_mdwID + a_hgm + bwyi*wyi + 
      brip*rip + blf*lf + bsub*sub + bds*ds + bdep*dep,
      #belev*elev + bcatch*catcharea + bFslope*flowslope +
      #blat*lat + bkf*kf + bclay + bshape*shape,
    a_mdwID[mdwID] ~ dnorm(0, sigma_mdwID),
    a_hgm[hgm] ~ dnorm(0, sigma_hgm),
    a ~ dnorm(0,100),
    c(a, bwyi, brip, bsub, bds, bdep, blf) ~ dnorm(0,10),
    sigma ~ cauchy(0,3),
    sigma_mdwID ~ dcauchy(0,1),
    sigma_hgm ~ dcauchy(0,1)
  ),
  data=dlist1, chains = 2, iter=5000, cores=4)

precis(m1b, depth=2)
plot(m1b) # trace plots good
dev.off()
plot(precis(m1b, depth=2))

post1b <- extract.samples(m1b)
dens( post1b$sigma_hgm , xlab="sigma" , ylim=c(0,25), xlim=c(0,0.7))
dens( post1b$sigma_mdwID , col=rangi2 , lwd=2 , add=TRUE )
text( 0.1, 22, "Mdw ID" , col=rangi2 )
text( 0.04 , 15 , "HGM Class" )


m2b <- map2stan(
  alist(
    ndwi ~ dnorm(mu, sigma), 
    mu <- a + a_mdwID + a_hgm + bwyi*wyi + 
      brip*rip + blf*lf + bsub*sub + bds*ds + bdep*dep,
      #belev*elev + bcatch*catcharea + bFslope*flowslope +
      #blat*lat + bkf*kf + bclay + bshape*shape,
    a_mdwID[mdwID] ~ dnorm(0, sigma_mdwID),
    a_hgm[hgm] ~ dnorm(0, sigma_hgm),
    a ~ dnorm(0,100),
    c(a, bwyi, brip, bsub, bds, bdep, blf) ~ dnorm(0,10),
    sigma ~ cauchy(0,3),
    sigma_mdwID ~ dcauchy(0,1),
    sigma_hgm ~ dcauchy(0,1)
  ),
  data=dlist2, chains = 2, iter=5000, cores=4)

precis(m2b)
plot(precis(m2b, depth=2))
plot(m2b)

# SAVE THEM
save(m1b, m2b, file = "./data_output/models_1b_2b_revised.rda")

compare(m1a, m1b)
compare(m2a, m2b)

post2b <- extract.samples(m2b)
dens( post2b$sigma_hgm , xlab="sigma", ylim=c(0,22))
dens( post2b$sigma_mdwID , col=rangi2 , lwd=2 , add=TRUE )
text( 0.1, 22, "Mdw ID" , col=rangi2 )
text( 0.03 , 16 , "HGM Class" )

# Looks like each varies about the same, though Mdw ID appears to have more variation than HGM Class within the model (makes sense).

```

Adding HGM class (type) as an additional intercept improves the model only marginally. It only techically adds a half parameter and improves the WAIC value by 0.4 or 0.6. Can't compare the NDVI and NDWI models at this point because they have slightly different numbers of observations. Should even the two so I can compare in the future.  

Use `dim(dfWI[-sample(nrow(dfVI),5),])`

        
```{r modb_hgm_dat, eval=F, echo=T} 
# Now add some of the meta meadow variables like elev, flowslope, etc.
m1b <- map2stan(
  alist(
    ndvi ~ dnorm(mu, sigma), 
    mu <- a + a_mdwID[mdwID] + bwyi*wyi + brip*rip + blf*lf + 
      bsub*sub + bds*ds + bdep*dep + 
      belev*elev + bcatch*catcharea + bFslope*flowslope +
      blat*lat + bkf*kf + bclay + bshape*shape,
    a ~ dnorm(11,100),
    a_mdwID[mdwID] ~ dnorm(11,sigma),
    c(bwyi, brip, blf, bsub, bds, bdep,
      belev, bcatch, bFslope, blat, bkf, bclay, bshape) ~ dnorm(0,10),
    sigma ~ cauchy(0,2)
  ),
  data=dlist1, chains = 2, iter=5000, cores=2)

m2b <- map2stan(
  alist(
    ndwi ~ dnorm(mu, sigma), 
    mu <- a + a_mdwID[mdwID] + bwyi*wyi + brip*rip + blf*lf + 
      bsub*sub + bds*ds + bdep*dep + 
      belev*elev + bcatch*catcharea + bFslope*flowslope +
      blat*lat + bkf*kf + bclay + bshape*shape,
    a ~ dnorm(11,100),
    a_mdwID[mdwID] ~ dnorm(11,sigma),
    c(bwyi, brip, blf, bsub, bds, bdep,
      belev, bcatch, bFslope, blat, bkf, bclay, bshape) ~ dnorm(0,10),
    sigma ~ cauchy(0,2)
  ),
  data=dlist2, chains = 2, iter=5000, cores=2)

summary(m1b) # see all 
plot(m1b) # see trace plots

par(mfrow=c(1,1))
plot(precis(m1b)) # see basic results with fixed effects
plot(precis(m1b, depth=2)) # see full results for each meadow
mtext("Varying effects model m1b")
postcheck(m1b)

save(m2a,m2b, file = "./data_output/models_2a_2b_revised.rda")

```

# Mixed Effect Model with Varying Intercepts for Different HGM types

```{r, eval=F, echo=F}


m1b<-map2stan(
  alist(
    ndvi ~ dnorm(mu,sigma),
    mu <- a + a_name + (b + b_name)*hgm,# + (b + b_name)*wtyr_typ,
    a ~ dnorm(0,100), # intercept
    b ~ dnorm(0,10), # slope
    c(a_name,b_name)[name] ~ dmvnorm2(0,sigma_name,Rho_name),
    sigma_name ~ dcauchy(0,1),
    Rho_name ~ dlkjcorr(2),
    sigma ~ dcauchy(0,1)),
  data=dlist, iter=1000, chains=2,cores=2)

precis( m1a , depth=2,
    pars=c("a","b","sigma_name","Rho_name") )

# rhats should be 1 or 1.00, and mean and STD should make sense (not wildly variable all over map). Correlations between slope and intercept (Rho_name 1,2 or vice versa) should potentially make sense too.


```


# BRT Models

```{r BRT}

source("./scripts/functions/brt.functions.R")


library(gbm)
library(dismo)


# Build model using code from Elith & Leathwick
set.seed(33)  # set seed to get repeatable model              

# BRT model: shannon -----

brtWI<-select(dfWI, mean, hgm_class_comb:flowrange_s)

gbm1a <- gbm.step(data=brtWI,
                  gbm.x = c(2:21),          
                  gbm.y = 1, 
                  family = "gaussian",
                  tree.complexity = 2,   
                  learning.rate = 0.005, 
                  bag.fraction = 0.75,
                  n.folds=10)   

summary(gbm1a)

# with NA included in model
topn3 = sum((summary(gbm3a, plotit=FALSE)$rel.inf)>=2)
topvar3 = as.character(summary(gbm3a, plotit=FALSE)$var[1:topn3])

par(mar=c(5,12,3,3))
barplot(rev(summary(gbm3a, plotit=FALSE)$rel.inf[1:topn3]), 
        horiz = TRUE, col = viridis(topn3), 
        names = rev(summary(gbm3a, plotit=FALSE)$var[1:topn3]), 
        xlab = "Relative influence",
        las=1, 
        main=paste0("Relative Influence: \nTop ",topn3," Vars, Shannon Index"))

# par(mar=c(5,4,2,3),oma=c(1,1,1,1), xpd=TRUE); gbm.plot(gbm3a, n.plots = 12, plot.layout=c(4,3), write.title=FALSE)



```
